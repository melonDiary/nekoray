// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: libcore.proto
// Protobuf C++ Version: 5.29.3

#ifndef libcore_2eproto_2epb_2eh
#define libcore_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029003
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_libcore_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_libcore_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_libcore_2eproto;
namespace libcore {
class EmptyReq;
struct EmptyReqDefaultTypeInternal;
extern EmptyReqDefaultTypeInternal _EmptyReq_default_instance_;
class EmptyResp;
struct EmptyRespDefaultTypeInternal;
extern EmptyRespDefaultTypeInternal _EmptyResp_default_instance_;
class ErrorResp;
struct ErrorRespDefaultTypeInternal;
extern ErrorRespDefaultTypeInternal _ErrorResp_default_instance_;
class ListConnectionsResp;
struct ListConnectionsRespDefaultTypeInternal;
extern ListConnectionsRespDefaultTypeInternal _ListConnectionsResp_default_instance_;
class LoadConfigReq;
struct LoadConfigReqDefaultTypeInternal;
extern LoadConfigReqDefaultTypeInternal _LoadConfigReq_default_instance_;
class QueryStatsReq;
struct QueryStatsReqDefaultTypeInternal;
extern QueryStatsReqDefaultTypeInternal _QueryStatsReq_default_instance_;
class QueryStatsResp;
struct QueryStatsRespDefaultTypeInternal;
extern QueryStatsRespDefaultTypeInternal _QueryStatsResp_default_instance_;
class TestReq;
struct TestReqDefaultTypeInternal;
extern TestReqDefaultTypeInternal _TestReq_default_instance_;
class TestResp;
struct TestRespDefaultTypeInternal;
extern TestRespDefaultTypeInternal _TestResp_default_instance_;
class UpdateReq;
struct UpdateReqDefaultTypeInternal;
extern UpdateReqDefaultTypeInternal _UpdateReq_default_instance_;
class UpdateResp;
struct UpdateRespDefaultTypeInternal;
extern UpdateRespDefaultTypeInternal _UpdateResp_default_instance_;
}  // namespace libcore
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace libcore {
enum TestMode : int {
  TcpPing = 0,
  UrlTest = 1,
  FullTest = 2,
  TestMode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  TestMode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool TestMode_IsValid(int value);
extern const uint32_t TestMode_internal_data_[];
constexpr TestMode TestMode_MIN = static_cast<TestMode>(0);
constexpr TestMode TestMode_MAX = static_cast<TestMode>(2);
constexpr int TestMode_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
TestMode_descriptor();
template <typename T>
const std::string& TestMode_Name(T value) {
  static_assert(std::is_same<T, TestMode>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to TestMode_Name().");
  return TestMode_Name(static_cast<TestMode>(value));
}
template <>
inline const std::string& TestMode_Name(TestMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TestMode_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool TestMode_Parse(absl::string_view name, TestMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TestMode>(
      TestMode_descriptor(), name, value);
}
enum UpdateAction : int {
  Check = 0,
  Download = 1,
  UpdateAction_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  UpdateAction_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool UpdateAction_IsValid(int value);
extern const uint32_t UpdateAction_internal_data_[];
constexpr UpdateAction UpdateAction_MIN = static_cast<UpdateAction>(0);
constexpr UpdateAction UpdateAction_MAX = static_cast<UpdateAction>(1);
constexpr int UpdateAction_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
UpdateAction_descriptor();
template <typename T>
const std::string& UpdateAction_Name(T value) {
  static_assert(std::is_same<T, UpdateAction>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to UpdateAction_Name().");
  return UpdateAction_Name(static_cast<UpdateAction>(value));
}
template <>
inline const std::string& UpdateAction_Name(UpdateAction value) {
  return ::google::protobuf::internal::NameOfDenseEnum<UpdateAction_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool UpdateAction_Parse(absl::string_view name, UpdateAction* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UpdateAction>(
      UpdateAction_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class UpdateResp final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:libcore.UpdateResp) */ {
 public:
  inline UpdateResp() : UpdateResp(nullptr) {}
  ~UpdateResp() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UpdateResp* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UpdateResp));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateResp(
      ::google::protobuf::internal::ConstantInitialized);

  inline UpdateResp(const UpdateResp& from) : UpdateResp(nullptr, from) {}
  inline UpdateResp(UpdateResp&& from) noexcept
      : UpdateResp(nullptr, std::move(from)) {}
  inline UpdateResp& operator=(const UpdateResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateResp& operator=(UpdateResp&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateResp* internal_default_instance() {
    return reinterpret_cast<const UpdateResp*>(
        &_UpdateResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(UpdateResp& a, UpdateResp& b) { a.Swap(&b); }
  inline void Swap(UpdateResp* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateResp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateResp* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UpdateResp>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateResp& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UpdateResp& from) { UpdateResp::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UpdateResp* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "libcore.UpdateResp"; }

 protected:
  explicit UpdateResp(::google::protobuf::Arena* arena);
  UpdateResp(::google::protobuf::Arena* arena, const UpdateResp& from);
  UpdateResp(::google::protobuf::Arena* arena, UpdateResp&& from) noexcept
      : UpdateResp(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kErrorFieldNumber = 1,
    kAssetsNameFieldNumber = 2,
    kDownloadUrlFieldNumber = 3,
    kReleaseUrlFieldNumber = 4,
    kReleaseNoteFieldNumber = 5,
    kIsPreReleaseFieldNumber = 6,
  };
  // string error = 1;
  void clear_error() ;
  const std::string& error() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error(Arg_&& arg, Args_... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* value);

  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(
      const std::string& value);
  std::string* _internal_mutable_error();

  public:
  // string assets_name = 2;
  void clear_assets_name() ;
  const std::string& assets_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_assets_name(Arg_&& arg, Args_... args);
  std::string* mutable_assets_name();
  PROTOBUF_NODISCARD std::string* release_assets_name();
  void set_allocated_assets_name(std::string* value);

  private:
  const std::string& _internal_assets_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_assets_name(
      const std::string& value);
  std::string* _internal_mutable_assets_name();

  public:
  // string download_url = 3;
  void clear_download_url() ;
  const std::string& download_url() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_download_url(Arg_&& arg, Args_... args);
  std::string* mutable_download_url();
  PROTOBUF_NODISCARD std::string* release_download_url();
  void set_allocated_download_url(std::string* value);

  private:
  const std::string& _internal_download_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_download_url(
      const std::string& value);
  std::string* _internal_mutable_download_url();

  public:
  // string release_url = 4;
  void clear_release_url() ;
  const std::string& release_url() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_release_url(Arg_&& arg, Args_... args);
  std::string* mutable_release_url();
  PROTOBUF_NODISCARD std::string* release_release_url();
  void set_allocated_release_url(std::string* value);

  private:
  const std::string& _internal_release_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_release_url(
      const std::string& value);
  std::string* _internal_mutable_release_url();

  public:
  // string release_note = 5;
  void clear_release_note() ;
  const std::string& release_note() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_release_note(Arg_&& arg, Args_... args);
  std::string* mutable_release_note();
  PROTOBUF_NODISCARD std::string* release_release_note();
  void set_allocated_release_note(std::string* value);

  private:
  const std::string& _internal_release_note() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_release_note(
      const std::string& value);
  std::string* _internal_mutable_release_note();

  public:
  // bool is_pre_release = 6;
  void clear_is_pre_release() ;
  bool is_pre_release() const;
  void set_is_pre_release(bool value);

  private:
  bool _internal_is_pre_release() const;
  void _internal_set_is_pre_release(bool value);

  public:
  // @@protoc_insertion_point(class_scope:libcore.UpdateResp)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 0,
      78, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const UpdateResp& from_msg);
    ::google::protobuf::internal::ArenaStringPtr error_;
    ::google::protobuf::internal::ArenaStringPtr assets_name_;
    ::google::protobuf::internal::ArenaStringPtr download_url_;
    ::google::protobuf::internal::ArenaStringPtr release_url_;
    ::google::protobuf::internal::ArenaStringPtr release_note_;
    bool is_pre_release_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_libcore_2eproto;
};
// -------------------------------------------------------------------

class UpdateReq final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:libcore.UpdateReq) */ {
 public:
  inline UpdateReq() : UpdateReq(nullptr) {}
  ~UpdateReq() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UpdateReq* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UpdateReq));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateReq(
      ::google::protobuf::internal::ConstantInitialized);

  inline UpdateReq(const UpdateReq& from) : UpdateReq(nullptr, from) {}
  inline UpdateReq(UpdateReq&& from) noexcept
      : UpdateReq(nullptr, std::move(from)) {}
  inline UpdateReq& operator=(const UpdateReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateReq& operator=(UpdateReq&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateReq* internal_default_instance() {
    return reinterpret_cast<const UpdateReq*>(
        &_UpdateReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(UpdateReq& a, UpdateReq& b) { a.Swap(&b); }
  inline void Swap(UpdateReq* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateReq* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UpdateReq>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateReq& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UpdateReq& from) { UpdateReq::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UpdateReq* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "libcore.UpdateReq"; }

 protected:
  explicit UpdateReq(::google::protobuf::Arena* arena);
  UpdateReq(::google::protobuf::Arena* arena, const UpdateReq& from);
  UpdateReq(::google::protobuf::Arena* arena, UpdateReq&& from) noexcept
      : UpdateReq(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kActionFieldNumber = 1,
    kCheckPreReleaseFieldNumber = 2,
  };
  // .libcore.UpdateAction action = 1;
  void clear_action() ;
  ::libcore::UpdateAction action() const;
  void set_action(::libcore::UpdateAction value);

  private:
  ::libcore::UpdateAction _internal_action() const;
  void _internal_set_action(::libcore::UpdateAction value);

  public:
  // bool check_pre_release = 2;
  void clear_check_pre_release() ;
  bool check_pre_release() const;
  void set_check_pre_release(bool value);

  private:
  bool _internal_check_pre_release() const;
  void _internal_set_check_pre_release(bool value);

  public:
  // @@protoc_insertion_point(class_scope:libcore.UpdateReq)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const UpdateReq& from_msg);
    int action_;
    bool check_pre_release_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_libcore_2eproto;
};
// -------------------------------------------------------------------

class TestResp final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:libcore.TestResp) */ {
 public:
  inline TestResp() : TestResp(nullptr) {}
  ~TestResp() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TestResp* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TestResp));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TestResp(
      ::google::protobuf::internal::ConstantInitialized);

  inline TestResp(const TestResp& from) : TestResp(nullptr, from) {}
  inline TestResp(TestResp&& from) noexcept
      : TestResp(nullptr, std::move(from)) {}
  inline TestResp& operator=(const TestResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestResp& operator=(TestResp&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestResp* internal_default_instance() {
    return reinterpret_cast<const TestResp*>(
        &_TestResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(TestResp& a, TestResp& b) { a.Swap(&b); }
  inline void Swap(TestResp* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestResp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestResp* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TestResp>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestResp& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TestResp& from) { TestResp::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TestResp* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "libcore.TestResp"; }

 protected:
  explicit TestResp(::google::protobuf::Arena* arena);
  TestResp(::google::protobuf::Arena* arena, const TestResp& from);
  TestResp(::google::protobuf::Arena* arena, TestResp&& from) noexcept
      : TestResp(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kErrorFieldNumber = 1,
    kFullReportFieldNumber = 3,
    kMsFieldNumber = 2,
  };
  // string error = 1;
  void clear_error() ;
  const std::string& error() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error(Arg_&& arg, Args_... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* value);

  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(
      const std::string& value);
  std::string* _internal_mutable_error();

  public:
  // string full_report = 3;
  void clear_full_report() ;
  const std::string& full_report() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_full_report(Arg_&& arg, Args_... args);
  std::string* mutable_full_report();
  PROTOBUF_NODISCARD std::string* release_full_report();
  void set_allocated_full_report(std::string* value);

  private:
  const std::string& _internal_full_report() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_full_report(
      const std::string& value);
  std::string* _internal_mutable_full_report();

  public:
  // int32 ms = 2;
  void clear_ms() ;
  ::int32_t ms() const;
  void set_ms(::int32_t value);

  private:
  ::int32_t _internal_ms() const;
  void _internal_set_ms(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:libcore.TestResp)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      41, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TestResp& from_msg);
    ::google::protobuf::internal::ArenaStringPtr error_;
    ::google::protobuf::internal::ArenaStringPtr full_report_;
    ::int32_t ms_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_libcore_2eproto;
};
// -------------------------------------------------------------------

class QueryStatsResp final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:libcore.QueryStatsResp) */ {
 public:
  inline QueryStatsResp() : QueryStatsResp(nullptr) {}
  ~QueryStatsResp() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(QueryStatsResp* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(QueryStatsResp));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR QueryStatsResp(
      ::google::protobuf::internal::ConstantInitialized);

  inline QueryStatsResp(const QueryStatsResp& from) : QueryStatsResp(nullptr, from) {}
  inline QueryStatsResp(QueryStatsResp&& from) noexcept
      : QueryStatsResp(nullptr, std::move(from)) {}
  inline QueryStatsResp& operator=(const QueryStatsResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryStatsResp& operator=(QueryStatsResp&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryStatsResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryStatsResp* internal_default_instance() {
    return reinterpret_cast<const QueryStatsResp*>(
        &_QueryStatsResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(QueryStatsResp& a, QueryStatsResp& b) { a.Swap(&b); }
  inline void Swap(QueryStatsResp* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryStatsResp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryStatsResp* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<QueryStatsResp>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const QueryStatsResp& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const QueryStatsResp& from) { QueryStatsResp::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(QueryStatsResp* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "libcore.QueryStatsResp"; }

 protected:
  explicit QueryStatsResp(::google::protobuf::Arena* arena);
  QueryStatsResp(::google::protobuf::Arena* arena, const QueryStatsResp& from);
  QueryStatsResp(::google::protobuf::Arena* arena, QueryStatsResp&& from) noexcept
      : QueryStatsResp(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTrafficFieldNumber = 1,
  };
  // int64 traffic = 1;
  void clear_traffic() ;
  ::int64_t traffic() const;
  void set_traffic(::int64_t value);

  private:
  ::int64_t _internal_traffic() const;
  void _internal_set_traffic(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:libcore.QueryStatsResp)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const QueryStatsResp& from_msg);
    ::int64_t traffic_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_libcore_2eproto;
};
// -------------------------------------------------------------------

class QueryStatsReq final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:libcore.QueryStatsReq) */ {
 public:
  inline QueryStatsReq() : QueryStatsReq(nullptr) {}
  ~QueryStatsReq() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(QueryStatsReq* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(QueryStatsReq));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR QueryStatsReq(
      ::google::protobuf::internal::ConstantInitialized);

  inline QueryStatsReq(const QueryStatsReq& from) : QueryStatsReq(nullptr, from) {}
  inline QueryStatsReq(QueryStatsReq&& from) noexcept
      : QueryStatsReq(nullptr, std::move(from)) {}
  inline QueryStatsReq& operator=(const QueryStatsReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryStatsReq& operator=(QueryStatsReq&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryStatsReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryStatsReq* internal_default_instance() {
    return reinterpret_cast<const QueryStatsReq*>(
        &_QueryStatsReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(QueryStatsReq& a, QueryStatsReq& b) { a.Swap(&b); }
  inline void Swap(QueryStatsReq* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryStatsReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryStatsReq* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<QueryStatsReq>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const QueryStatsReq& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const QueryStatsReq& from) { QueryStatsReq::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(QueryStatsReq* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "libcore.QueryStatsReq"; }

 protected:
  explicit QueryStatsReq(::google::protobuf::Arena* arena);
  QueryStatsReq(::google::protobuf::Arena* arena, const QueryStatsReq& from);
  QueryStatsReq(::google::protobuf::Arena* arena, QueryStatsReq&& from) noexcept
      : QueryStatsReq(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTagFieldNumber = 1,
    kDirectFieldNumber = 2,
  };
  // string tag = 1;
  void clear_tag() ;
  const std::string& tag() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_tag(Arg_&& arg, Args_... args);
  std::string* mutable_tag();
  PROTOBUF_NODISCARD std::string* release_tag();
  void set_allocated_tag(std::string* value);

  private:
  const std::string& _internal_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tag(
      const std::string& value);
  std::string* _internal_mutable_tag();

  public:
  // string direct = 2;
  void clear_direct() ;
  const std::string& direct() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_direct(Arg_&& arg, Args_... args);
  std::string* mutable_direct();
  PROTOBUF_NODISCARD std::string* release_direct();
  void set_allocated_direct(std::string* value);

  private:
  const std::string& _internal_direct() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_direct(
      const std::string& value);
  std::string* _internal_mutable_direct();

  public:
  // @@protoc_insertion_point(class_scope:libcore.QueryStatsReq)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      39, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const QueryStatsReq& from_msg);
    ::google::protobuf::internal::ArenaStringPtr tag_;
    ::google::protobuf::internal::ArenaStringPtr direct_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_libcore_2eproto;
};
// -------------------------------------------------------------------

class LoadConfigReq final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:libcore.LoadConfigReq) */ {
 public:
  inline LoadConfigReq() : LoadConfigReq(nullptr) {}
  ~LoadConfigReq() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(LoadConfigReq* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(LoadConfigReq));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LoadConfigReq(
      ::google::protobuf::internal::ConstantInitialized);

  inline LoadConfigReq(const LoadConfigReq& from) : LoadConfigReq(nullptr, from) {}
  inline LoadConfigReq(LoadConfigReq&& from) noexcept
      : LoadConfigReq(nullptr, std::move(from)) {}
  inline LoadConfigReq& operator=(const LoadConfigReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadConfigReq& operator=(LoadConfigReq&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoadConfigReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoadConfigReq* internal_default_instance() {
    return reinterpret_cast<const LoadConfigReq*>(
        &_LoadConfigReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(LoadConfigReq& a, LoadConfigReq& b) { a.Swap(&b); }
  inline void Swap(LoadConfigReq* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadConfigReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoadConfigReq* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<LoadConfigReq>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LoadConfigReq& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LoadConfigReq& from) { LoadConfigReq::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(LoadConfigReq* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "libcore.LoadConfigReq"; }

 protected:
  explicit LoadConfigReq(::google::protobuf::Arena* arena);
  LoadConfigReq(::google::protobuf::Arena* arena, const LoadConfigReq& from);
  LoadConfigReq(::google::protobuf::Arena* arena, LoadConfigReq&& from) noexcept
      : LoadConfigReq(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStatsOutboundsFieldNumber = 3,
    kCoreConfigFieldNumber = 1,
    kEnableNekorayConnectionsFieldNumber = 2,
  };
  // repeated string stats_outbounds = 3;
  int stats_outbounds_size() const;
  private:
  int _internal_stats_outbounds_size() const;

  public:
  void clear_stats_outbounds() ;
  const std::string& stats_outbounds(int index) const;
  std::string* mutable_stats_outbounds(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_stats_outbounds(int index, Arg_&& value, Args_... args);
  std::string* add_stats_outbounds();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_stats_outbounds(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& stats_outbounds() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_stats_outbounds();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_stats_outbounds() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_stats_outbounds();

  public:
  // string core_config = 1;
  void clear_core_config() ;
  const std::string& core_config() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_core_config(Arg_&& arg, Args_... args);
  std::string* mutable_core_config();
  PROTOBUF_NODISCARD std::string* release_core_config();
  void set_allocated_core_config(std::string* value);

  private:
  const std::string& _internal_core_config() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_core_config(
      const std::string& value);
  std::string* _internal_mutable_core_config();

  public:
  // bool enable_nekoray_connections = 2;
  void clear_enable_nekoray_connections() ;
  bool enable_nekoray_connections() const;
  void set_enable_nekoray_connections(bool value);

  private:
  bool _internal_enable_nekoray_connections() const;
  void _internal_set_enable_nekoray_connections(bool value);

  public:
  // @@protoc_insertion_point(class_scope:libcore.LoadConfigReq)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      56, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const LoadConfigReq& from_msg);
    ::google::protobuf::RepeatedPtrField<std::string> stats_outbounds_;
    ::google::protobuf::internal::ArenaStringPtr core_config_;
    bool enable_nekoray_connections_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_libcore_2eproto;
};
// -------------------------------------------------------------------

class ListConnectionsResp final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:libcore.ListConnectionsResp) */ {
 public:
  inline ListConnectionsResp() : ListConnectionsResp(nullptr) {}
  ~ListConnectionsResp() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ListConnectionsResp* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ListConnectionsResp));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ListConnectionsResp(
      ::google::protobuf::internal::ConstantInitialized);

  inline ListConnectionsResp(const ListConnectionsResp& from) : ListConnectionsResp(nullptr, from) {}
  inline ListConnectionsResp(ListConnectionsResp&& from) noexcept
      : ListConnectionsResp(nullptr, std::move(from)) {}
  inline ListConnectionsResp& operator=(const ListConnectionsResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListConnectionsResp& operator=(ListConnectionsResp&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListConnectionsResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListConnectionsResp* internal_default_instance() {
    return reinterpret_cast<const ListConnectionsResp*>(
        &_ListConnectionsResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(ListConnectionsResp& a, ListConnectionsResp& b) { a.Swap(&b); }
  inline void Swap(ListConnectionsResp* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListConnectionsResp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListConnectionsResp* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ListConnectionsResp>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListConnectionsResp& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ListConnectionsResp& from) { ListConnectionsResp::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ListConnectionsResp* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "libcore.ListConnectionsResp"; }

 protected:
  explicit ListConnectionsResp(::google::protobuf::Arena* arena);
  ListConnectionsResp(::google::protobuf::Arena* arena, const ListConnectionsResp& from);
  ListConnectionsResp(::google::protobuf::Arena* arena, ListConnectionsResp&& from) noexcept
      : ListConnectionsResp(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNekorayConnectionsJsonFieldNumber = 1,
  };
  // string nekoray_connections_json = 1;
  void clear_nekoray_connections_json() ;
  const std::string& nekoray_connections_json() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_nekoray_connections_json(Arg_&& arg, Args_... args);
  std::string* mutable_nekoray_connections_json();
  PROTOBUF_NODISCARD std::string* release_nekoray_connections_json();
  void set_allocated_nekoray_connections_json(std::string* value);

  private:
  const std::string& _internal_nekoray_connections_json() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nekoray_connections_json(
      const std::string& value);
  std::string* _internal_mutable_nekoray_connections_json();

  public:
  // @@protoc_insertion_point(class_scope:libcore.ListConnectionsResp)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      60, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ListConnectionsResp& from_msg);
    ::google::protobuf::internal::ArenaStringPtr nekoray_connections_json_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_libcore_2eproto;
};
// -------------------------------------------------------------------

class ErrorResp final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:libcore.ErrorResp) */ {
 public:
  inline ErrorResp() : ErrorResp(nullptr) {}
  ~ErrorResp() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ErrorResp* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ErrorResp));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ErrorResp(
      ::google::protobuf::internal::ConstantInitialized);

  inline ErrorResp(const ErrorResp& from) : ErrorResp(nullptr, from) {}
  inline ErrorResp(ErrorResp&& from) noexcept
      : ErrorResp(nullptr, std::move(from)) {}
  inline ErrorResp& operator=(const ErrorResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline ErrorResp& operator=(ErrorResp&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ErrorResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const ErrorResp* internal_default_instance() {
    return reinterpret_cast<const ErrorResp*>(
        &_ErrorResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(ErrorResp& a, ErrorResp& b) { a.Swap(&b); }
  inline void Swap(ErrorResp* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ErrorResp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ErrorResp* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ErrorResp>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ErrorResp& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ErrorResp& from) { ErrorResp::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ErrorResp* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "libcore.ErrorResp"; }

 protected:
  explicit ErrorResp(::google::protobuf::Arena* arena);
  ErrorResp(::google::protobuf::Arena* arena, const ErrorResp& from);
  ErrorResp(::google::protobuf::Arena* arena, ErrorResp&& from) noexcept
      : ErrorResp(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kErrorFieldNumber = 1,
  };
  // string error = 1;
  void clear_error() ;
  const std::string& error() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error(Arg_&& arg, Args_... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* value);

  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(
      const std::string& value);
  std::string* _internal_mutable_error();

  public:
  // @@protoc_insertion_point(class_scope:libcore.ErrorResp)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      31, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ErrorResp& from_msg);
    ::google::protobuf::internal::ArenaStringPtr error_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_libcore_2eproto;
};
// -------------------------------------------------------------------

class EmptyResp final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:libcore.EmptyResp) */ {
 public:
  inline EmptyResp() : EmptyResp(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EmptyResp* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EmptyResp));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EmptyResp(
      ::google::protobuf::internal::ConstantInitialized);

  inline EmptyResp(const EmptyResp& from) : EmptyResp(nullptr, from) {}
  inline EmptyResp(EmptyResp&& from) noexcept
      : EmptyResp(nullptr, std::move(from)) {}
  inline EmptyResp& operator=(const EmptyResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline EmptyResp& operator=(EmptyResp&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EmptyResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const EmptyResp* internal_default_instance() {
    return reinterpret_cast<const EmptyResp*>(
        &_EmptyResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(EmptyResp& a, EmptyResp& b) { a.Swap(&b); }
  inline void Swap(EmptyResp* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EmptyResp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EmptyResp* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<EmptyResp>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const EmptyResp& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const EmptyResp& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "libcore.EmptyResp"; }

 protected:
  explicit EmptyResp(::google::protobuf::Arena* arena);
  EmptyResp(::google::protobuf::Arena* arena, const EmptyResp& from);
  EmptyResp(::google::protobuf::Arena* arena, EmptyResp&& from) noexcept
      : EmptyResp(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:libcore.EmptyResp)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const EmptyResp& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_libcore_2eproto;
};
// -------------------------------------------------------------------

class EmptyReq final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:libcore.EmptyReq) */ {
 public:
  inline EmptyReq() : EmptyReq(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EmptyReq* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EmptyReq));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EmptyReq(
      ::google::protobuf::internal::ConstantInitialized);

  inline EmptyReq(const EmptyReq& from) : EmptyReq(nullptr, from) {}
  inline EmptyReq(EmptyReq&& from) noexcept
      : EmptyReq(nullptr, std::move(from)) {}
  inline EmptyReq& operator=(const EmptyReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline EmptyReq& operator=(EmptyReq&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EmptyReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const EmptyReq* internal_default_instance() {
    return reinterpret_cast<const EmptyReq*>(
        &_EmptyReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(EmptyReq& a, EmptyReq& b) { a.Swap(&b); }
  inline void Swap(EmptyReq* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EmptyReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EmptyReq* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<EmptyReq>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const EmptyReq& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const EmptyReq& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "libcore.EmptyReq"; }

 protected:
  explicit EmptyReq(::google::protobuf::Arena* arena);
  EmptyReq(::google::protobuf::Arena* arena, const EmptyReq& from);
  EmptyReq(::google::protobuf::Arena* arena, EmptyReq&& from) noexcept
      : EmptyReq(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:libcore.EmptyReq)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const EmptyReq& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_libcore_2eproto;
};
// -------------------------------------------------------------------

class TestReq final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:libcore.TestReq) */ {
 public:
  inline TestReq() : TestReq(nullptr) {}
  ~TestReq() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TestReq* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TestReq));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TestReq(
      ::google::protobuf::internal::ConstantInitialized);

  inline TestReq(const TestReq& from) : TestReq(nullptr, from) {}
  inline TestReq(TestReq&& from) noexcept
      : TestReq(nullptr, std::move(from)) {}
  inline TestReq& operator=(const TestReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestReq& operator=(TestReq&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestReq* internal_default_instance() {
    return reinterpret_cast<const TestReq*>(
        &_TestReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(TestReq& a, TestReq& b) { a.Swap(&b); }
  inline void Swap(TestReq* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestReq* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TestReq>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestReq& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TestReq& from) { TestReq::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TestReq* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "libcore.TestReq"; }

 protected:
  explicit TestReq(::google::protobuf::Arena* arena);
  TestReq(::google::protobuf::Arena* arena, const TestReq& from);
  TestReq(::google::protobuf::Arena* arena, TestReq&& from) noexcept
      : TestReq(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAddressFieldNumber = 2,
    kInboundFieldNumber = 4,
    kUrlFieldNumber = 5,
    kInAddressFieldNumber = 7,
    kFullSpeedUrlFieldNumber = 13,
    kConfigFieldNumber = 3,
    kModeFieldNumber = 1,
    kTimeoutFieldNumber = 6,
    kFullLatencyFieldNumber = 8,
    kFullSpeedFieldNumber = 9,
    kFullInOutFieldNumber = 10,
    kFullUdpLatencyFieldNumber = 12,
    kFullNatFieldNumber = 11,
    kFullSpeedTimeoutFieldNumber = 14,
  };
  // string address = 2;
  void clear_address() ;
  const std::string& address() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_address(Arg_&& arg, Args_... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* value);

  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(
      const std::string& value);
  std::string* _internal_mutable_address();

  public:
  // string inbound = 4;
  void clear_inbound() ;
  const std::string& inbound() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_inbound(Arg_&& arg, Args_... args);
  std::string* mutable_inbound();
  PROTOBUF_NODISCARD std::string* release_inbound();
  void set_allocated_inbound(std::string* value);

  private:
  const std::string& _internal_inbound() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_inbound(
      const std::string& value);
  std::string* _internal_mutable_inbound();

  public:
  // string url = 5;
  void clear_url() ;
  const std::string& url() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_url(Arg_&& arg, Args_... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* value);

  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(
      const std::string& value);
  std::string* _internal_mutable_url();

  public:
  // string in_address = 7;
  void clear_in_address() ;
  const std::string& in_address() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_in_address(Arg_&& arg, Args_... args);
  std::string* mutable_in_address();
  PROTOBUF_NODISCARD std::string* release_in_address();
  void set_allocated_in_address(std::string* value);

  private:
  const std::string& _internal_in_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_in_address(
      const std::string& value);
  std::string* _internal_mutable_in_address();

  public:
  // string full_speed_url = 13;
  void clear_full_speed_url() ;
  const std::string& full_speed_url() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_full_speed_url(Arg_&& arg, Args_... args);
  std::string* mutable_full_speed_url();
  PROTOBUF_NODISCARD std::string* release_full_speed_url();
  void set_allocated_full_speed_url(std::string* value);

  private:
  const std::string& _internal_full_speed_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_full_speed_url(
      const std::string& value);
  std::string* _internal_mutable_full_speed_url();

  public:
  // .libcore.LoadConfigReq config = 3;
  bool has_config() const;
  void clear_config() ;
  const ::libcore::LoadConfigReq& config() const;
  PROTOBUF_NODISCARD ::libcore::LoadConfigReq* release_config();
  ::libcore::LoadConfigReq* mutable_config();
  void set_allocated_config(::libcore::LoadConfigReq* value);
  void unsafe_arena_set_allocated_config(::libcore::LoadConfigReq* value);
  ::libcore::LoadConfigReq* unsafe_arena_release_config();

  private:
  const ::libcore::LoadConfigReq& _internal_config() const;
  ::libcore::LoadConfigReq* _internal_mutable_config();

  public:
  // .libcore.TestMode mode = 1;
  void clear_mode() ;
  ::libcore::TestMode mode() const;
  void set_mode(::libcore::TestMode value);

  private:
  ::libcore::TestMode _internal_mode() const;
  void _internal_set_mode(::libcore::TestMode value);

  public:
  // int32 timeout = 6;
  void clear_timeout() ;
  ::int32_t timeout() const;
  void set_timeout(::int32_t value);

  private:
  ::int32_t _internal_timeout() const;
  void _internal_set_timeout(::int32_t value);

  public:
  // bool full_latency = 8;
  void clear_full_latency() ;
  bool full_latency() const;
  void set_full_latency(bool value);

  private:
  bool _internal_full_latency() const;
  void _internal_set_full_latency(bool value);

  public:
  // bool full_speed = 9;
  void clear_full_speed() ;
  bool full_speed() const;
  void set_full_speed(bool value);

  private:
  bool _internal_full_speed() const;
  void _internal_set_full_speed(bool value);

  public:
  // bool full_in_out = 10;
  void clear_full_in_out() ;
  bool full_in_out() const;
  void set_full_in_out(bool value);

  private:
  bool _internal_full_in_out() const;
  void _internal_set_full_in_out(bool value);

  public:
  // bool full_udp_latency = 12;
  void clear_full_udp_latency() ;
  bool full_udp_latency() const;
  void set_full_udp_latency(bool value);

  private:
  bool _internal_full_udp_latency() const;
  void _internal_set_full_udp_latency(bool value);

  public:
  // bool full_nat = 11 [deprecated = true];
  [[deprecated]]  void clear_full_nat() ;
  [[deprecated]] bool full_nat() const;
  [[deprecated]] void set_full_nat(bool value);

  private:
  bool _internal_full_nat() const;
  void _internal_set_full_nat(bool value);

  public:
  // int32 full_speed_timeout = 14;
  void clear_full_speed_timeout() ;
  ::int32_t full_speed_timeout() const;
  void set_full_speed_timeout(::int32_t value);

  private:
  ::int32_t _internal_full_speed_timeout() const;
  void _internal_set_full_speed_timeout(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:libcore.TestReq)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 14, 1,
      73, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TestReq& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr address_;
    ::google::protobuf::internal::ArenaStringPtr inbound_;
    ::google::protobuf::internal::ArenaStringPtr url_;
    ::google::protobuf::internal::ArenaStringPtr in_address_;
    ::google::protobuf::internal::ArenaStringPtr full_speed_url_;
    ::libcore::LoadConfigReq* config_;
    int mode_;
    ::int32_t timeout_;
    bool full_latency_;
    bool full_speed_;
    bool full_in_out_;
    bool full_udp_latency_;
    bool full_nat_;
    ::int32_t full_speed_timeout_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_libcore_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// EmptyReq

// -------------------------------------------------------------------

// EmptyResp

// -------------------------------------------------------------------

// ErrorResp

// string error = 1;
inline void ErrorResp::clear_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_.ClearToEmpty();
}
inline const std::string& ErrorResp::error() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:libcore.ErrorResp.error)
  return _internal_error();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ErrorResp::set_error(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:libcore.ErrorResp.error)
}
inline std::string* ErrorResp::mutable_error() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:libcore.ErrorResp.error)
  return _s;
}
inline const std::string& ErrorResp::_internal_error() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.error_.Get();
}
inline void ErrorResp::_internal_set_error(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_.Set(value, GetArena());
}
inline std::string* ErrorResp::_internal_mutable_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.error_.Mutable( GetArena());
}
inline std::string* ErrorResp::release_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:libcore.ErrorResp.error)
  return _impl_.error_.Release();
}
inline void ErrorResp::set_allocated_error(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:libcore.ErrorResp.error)
}

// -------------------------------------------------------------------

// LoadConfigReq

// string core_config = 1;
inline void LoadConfigReq::clear_core_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.core_config_.ClearToEmpty();
}
inline const std::string& LoadConfigReq::core_config() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:libcore.LoadConfigReq.core_config)
  return _internal_core_config();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LoadConfigReq::set_core_config(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.core_config_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:libcore.LoadConfigReq.core_config)
}
inline std::string* LoadConfigReq::mutable_core_config() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_core_config();
  // @@protoc_insertion_point(field_mutable:libcore.LoadConfigReq.core_config)
  return _s;
}
inline const std::string& LoadConfigReq::_internal_core_config() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.core_config_.Get();
}
inline void LoadConfigReq::_internal_set_core_config(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.core_config_.Set(value, GetArena());
}
inline std::string* LoadConfigReq::_internal_mutable_core_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.core_config_.Mutable( GetArena());
}
inline std::string* LoadConfigReq::release_core_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:libcore.LoadConfigReq.core_config)
  return _impl_.core_config_.Release();
}
inline void LoadConfigReq::set_allocated_core_config(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.core_config_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.core_config_.IsDefault()) {
    _impl_.core_config_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:libcore.LoadConfigReq.core_config)
}

// bool enable_nekoray_connections = 2;
inline void LoadConfigReq::clear_enable_nekoray_connections() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enable_nekoray_connections_ = false;
}
inline bool LoadConfigReq::enable_nekoray_connections() const {
  // @@protoc_insertion_point(field_get:libcore.LoadConfigReq.enable_nekoray_connections)
  return _internal_enable_nekoray_connections();
}
inline void LoadConfigReq::set_enable_nekoray_connections(bool value) {
  _internal_set_enable_nekoray_connections(value);
  // @@protoc_insertion_point(field_set:libcore.LoadConfigReq.enable_nekoray_connections)
}
inline bool LoadConfigReq::_internal_enable_nekoray_connections() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.enable_nekoray_connections_;
}
inline void LoadConfigReq::_internal_set_enable_nekoray_connections(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enable_nekoray_connections_ = value;
}

// repeated string stats_outbounds = 3;
inline int LoadConfigReq::_internal_stats_outbounds_size() const {
  return _internal_stats_outbounds().size();
}
inline int LoadConfigReq::stats_outbounds_size() const {
  return _internal_stats_outbounds_size();
}
inline void LoadConfigReq::clear_stats_outbounds() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stats_outbounds_.Clear();
}
inline std::string* LoadConfigReq::add_stats_outbounds() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_stats_outbounds()->Add();
  // @@protoc_insertion_point(field_add_mutable:libcore.LoadConfigReq.stats_outbounds)
  return _s;
}
inline const std::string& LoadConfigReq::stats_outbounds(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:libcore.LoadConfigReq.stats_outbounds)
  return _internal_stats_outbounds().Get(index);
}
inline std::string* LoadConfigReq::mutable_stats_outbounds(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:libcore.LoadConfigReq.stats_outbounds)
  return _internal_mutable_stats_outbounds()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void LoadConfigReq::set_stats_outbounds(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_stats_outbounds()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:libcore.LoadConfigReq.stats_outbounds)
}
template <typename Arg_, typename... Args_>
inline void LoadConfigReq::add_stats_outbounds(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_stats_outbounds(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:libcore.LoadConfigReq.stats_outbounds)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
LoadConfigReq::stats_outbounds() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:libcore.LoadConfigReq.stats_outbounds)
  return _internal_stats_outbounds();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
LoadConfigReq::mutable_stats_outbounds() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:libcore.LoadConfigReq.stats_outbounds)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_stats_outbounds();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
LoadConfigReq::_internal_stats_outbounds() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.stats_outbounds_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
LoadConfigReq::_internal_mutable_stats_outbounds() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.stats_outbounds_;
}

// -------------------------------------------------------------------

// TestReq

// .libcore.TestMode mode = 1;
inline void TestReq::clear_mode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mode_ = 0;
}
inline ::libcore::TestMode TestReq::mode() const {
  // @@protoc_insertion_point(field_get:libcore.TestReq.mode)
  return _internal_mode();
}
inline void TestReq::set_mode(::libcore::TestMode value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:libcore.TestReq.mode)
}
inline ::libcore::TestMode TestReq::_internal_mode() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::libcore::TestMode>(_impl_.mode_);
}
inline void TestReq::_internal_set_mode(::libcore::TestMode value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mode_ = value;
}

// int32 timeout = 6;
inline void TestReq::clear_timeout() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeout_ = 0;
}
inline ::int32_t TestReq::timeout() const {
  // @@protoc_insertion_point(field_get:libcore.TestReq.timeout)
  return _internal_timeout();
}
inline void TestReq::set_timeout(::int32_t value) {
  _internal_set_timeout(value);
  // @@protoc_insertion_point(field_set:libcore.TestReq.timeout)
}
inline ::int32_t TestReq::_internal_timeout() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timeout_;
}
inline void TestReq::_internal_set_timeout(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeout_ = value;
}

// string address = 2;
inline void TestReq::clear_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.address_.ClearToEmpty();
}
inline const std::string& TestReq::address() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:libcore.TestReq.address)
  return _internal_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TestReq::set_address(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.address_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:libcore.TestReq.address)
}
inline std::string* TestReq::mutable_address() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:libcore.TestReq.address)
  return _s;
}
inline const std::string& TestReq::_internal_address() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.address_.Get();
}
inline void TestReq::_internal_set_address(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.address_.Set(value, GetArena());
}
inline std::string* TestReq::_internal_mutable_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.address_.Mutable( GetArena());
}
inline std::string* TestReq::release_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:libcore.TestReq.address)
  return _impl_.address_.Release();
}
inline void TestReq::set_allocated_address(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.address_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:libcore.TestReq.address)
}

// .libcore.LoadConfigReq config = 3;
inline bool TestReq::has_config() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.config_ != nullptr);
  return value;
}
inline void TestReq::clear_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.config_ != nullptr) _impl_.config_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::libcore::LoadConfigReq& TestReq::_internal_config() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::libcore::LoadConfigReq* p = _impl_.config_;
  return p != nullptr ? *p : reinterpret_cast<const ::libcore::LoadConfigReq&>(::libcore::_LoadConfigReq_default_instance_);
}
inline const ::libcore::LoadConfigReq& TestReq::config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:libcore.TestReq.config)
  return _internal_config();
}
inline void TestReq::unsafe_arena_set_allocated_config(::libcore::LoadConfigReq* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.config_);
  }
  _impl_.config_ = reinterpret_cast<::libcore::LoadConfigReq*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:libcore.TestReq.config)
}
inline ::libcore::LoadConfigReq* TestReq::release_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::libcore::LoadConfigReq* released = _impl_.config_;
  _impl_.config_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::libcore::LoadConfigReq* TestReq::unsafe_arena_release_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:libcore.TestReq.config)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::libcore::LoadConfigReq* temp = _impl_.config_;
  _impl_.config_ = nullptr;
  return temp;
}
inline ::libcore::LoadConfigReq* TestReq::_internal_mutable_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.config_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::libcore::LoadConfigReq>(GetArena());
    _impl_.config_ = reinterpret_cast<::libcore::LoadConfigReq*>(p);
  }
  return _impl_.config_;
}
inline ::libcore::LoadConfigReq* TestReq::mutable_config() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::libcore::LoadConfigReq* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:libcore.TestReq.config)
  return _msg;
}
inline void TestReq::set_allocated_config(::libcore::LoadConfigReq* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.config_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.config_ = reinterpret_cast<::libcore::LoadConfigReq*>(value);
  // @@protoc_insertion_point(field_set_allocated:libcore.TestReq.config)
}

// string inbound = 4;
inline void TestReq::clear_inbound() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.inbound_.ClearToEmpty();
}
inline const std::string& TestReq::inbound() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:libcore.TestReq.inbound)
  return _internal_inbound();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TestReq::set_inbound(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.inbound_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:libcore.TestReq.inbound)
}
inline std::string* TestReq::mutable_inbound() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_inbound();
  // @@protoc_insertion_point(field_mutable:libcore.TestReq.inbound)
  return _s;
}
inline const std::string& TestReq::_internal_inbound() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.inbound_.Get();
}
inline void TestReq::_internal_set_inbound(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.inbound_.Set(value, GetArena());
}
inline std::string* TestReq::_internal_mutable_inbound() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.inbound_.Mutable( GetArena());
}
inline std::string* TestReq::release_inbound() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:libcore.TestReq.inbound)
  return _impl_.inbound_.Release();
}
inline void TestReq::set_allocated_inbound(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.inbound_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.inbound_.IsDefault()) {
    _impl_.inbound_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:libcore.TestReq.inbound)
}

// string url = 5;
inline void TestReq::clear_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.url_.ClearToEmpty();
}
inline const std::string& TestReq::url() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:libcore.TestReq.url)
  return _internal_url();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TestReq::set_url(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.url_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:libcore.TestReq.url)
}
inline std::string* TestReq::mutable_url() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:libcore.TestReq.url)
  return _s;
}
inline const std::string& TestReq::_internal_url() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.url_.Get();
}
inline void TestReq::_internal_set_url(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.url_.Set(value, GetArena());
}
inline std::string* TestReq::_internal_mutable_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.url_.Mutable( GetArena());
}
inline std::string* TestReq::release_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:libcore.TestReq.url)
  return _impl_.url_.Release();
}
inline void TestReq::set_allocated_url(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.url_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:libcore.TestReq.url)
}

// string in_address = 7;
inline void TestReq::clear_in_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.in_address_.ClearToEmpty();
}
inline const std::string& TestReq::in_address() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:libcore.TestReq.in_address)
  return _internal_in_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TestReq::set_in_address(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.in_address_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:libcore.TestReq.in_address)
}
inline std::string* TestReq::mutable_in_address() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_in_address();
  // @@protoc_insertion_point(field_mutable:libcore.TestReq.in_address)
  return _s;
}
inline const std::string& TestReq::_internal_in_address() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.in_address_.Get();
}
inline void TestReq::_internal_set_in_address(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.in_address_.Set(value, GetArena());
}
inline std::string* TestReq::_internal_mutable_in_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.in_address_.Mutable( GetArena());
}
inline std::string* TestReq::release_in_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:libcore.TestReq.in_address)
  return _impl_.in_address_.Release();
}
inline void TestReq::set_allocated_in_address(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.in_address_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.in_address_.IsDefault()) {
    _impl_.in_address_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:libcore.TestReq.in_address)
}

// bool full_latency = 8;
inline void TestReq::clear_full_latency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.full_latency_ = false;
}
inline bool TestReq::full_latency() const {
  // @@protoc_insertion_point(field_get:libcore.TestReq.full_latency)
  return _internal_full_latency();
}
inline void TestReq::set_full_latency(bool value) {
  _internal_set_full_latency(value);
  // @@protoc_insertion_point(field_set:libcore.TestReq.full_latency)
}
inline bool TestReq::_internal_full_latency() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.full_latency_;
}
inline void TestReq::_internal_set_full_latency(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.full_latency_ = value;
}

// bool full_speed = 9;
inline void TestReq::clear_full_speed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.full_speed_ = false;
}
inline bool TestReq::full_speed() const {
  // @@protoc_insertion_point(field_get:libcore.TestReq.full_speed)
  return _internal_full_speed();
}
inline void TestReq::set_full_speed(bool value) {
  _internal_set_full_speed(value);
  // @@protoc_insertion_point(field_set:libcore.TestReq.full_speed)
}
inline bool TestReq::_internal_full_speed() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.full_speed_;
}
inline void TestReq::_internal_set_full_speed(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.full_speed_ = value;
}

// string full_speed_url = 13;
inline void TestReq::clear_full_speed_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.full_speed_url_.ClearToEmpty();
}
inline const std::string& TestReq::full_speed_url() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:libcore.TestReq.full_speed_url)
  return _internal_full_speed_url();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TestReq::set_full_speed_url(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.full_speed_url_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:libcore.TestReq.full_speed_url)
}
inline std::string* TestReq::mutable_full_speed_url() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_full_speed_url();
  // @@protoc_insertion_point(field_mutable:libcore.TestReq.full_speed_url)
  return _s;
}
inline const std::string& TestReq::_internal_full_speed_url() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.full_speed_url_.Get();
}
inline void TestReq::_internal_set_full_speed_url(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.full_speed_url_.Set(value, GetArena());
}
inline std::string* TestReq::_internal_mutable_full_speed_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.full_speed_url_.Mutable( GetArena());
}
inline std::string* TestReq::release_full_speed_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:libcore.TestReq.full_speed_url)
  return _impl_.full_speed_url_.Release();
}
inline void TestReq::set_allocated_full_speed_url(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.full_speed_url_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.full_speed_url_.IsDefault()) {
    _impl_.full_speed_url_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:libcore.TestReq.full_speed_url)
}

// int32 full_speed_timeout = 14;
inline void TestReq::clear_full_speed_timeout() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.full_speed_timeout_ = 0;
}
inline ::int32_t TestReq::full_speed_timeout() const {
  // @@protoc_insertion_point(field_get:libcore.TestReq.full_speed_timeout)
  return _internal_full_speed_timeout();
}
inline void TestReq::set_full_speed_timeout(::int32_t value) {
  _internal_set_full_speed_timeout(value);
  // @@protoc_insertion_point(field_set:libcore.TestReq.full_speed_timeout)
}
inline ::int32_t TestReq::_internal_full_speed_timeout() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.full_speed_timeout_;
}
inline void TestReq::_internal_set_full_speed_timeout(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.full_speed_timeout_ = value;
}

// bool full_in_out = 10;
inline void TestReq::clear_full_in_out() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.full_in_out_ = false;
}
inline bool TestReq::full_in_out() const {
  // @@protoc_insertion_point(field_get:libcore.TestReq.full_in_out)
  return _internal_full_in_out();
}
inline void TestReq::set_full_in_out(bool value) {
  _internal_set_full_in_out(value);
  // @@protoc_insertion_point(field_set:libcore.TestReq.full_in_out)
}
inline bool TestReq::_internal_full_in_out() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.full_in_out_;
}
inline void TestReq::_internal_set_full_in_out(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.full_in_out_ = value;
}

// bool full_udp_latency = 12;
inline void TestReq::clear_full_udp_latency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.full_udp_latency_ = false;
}
inline bool TestReq::full_udp_latency() const {
  // @@protoc_insertion_point(field_get:libcore.TestReq.full_udp_latency)
  return _internal_full_udp_latency();
}
inline void TestReq::set_full_udp_latency(bool value) {
  _internal_set_full_udp_latency(value);
  // @@protoc_insertion_point(field_set:libcore.TestReq.full_udp_latency)
}
inline bool TestReq::_internal_full_udp_latency() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.full_udp_latency_;
}
inline void TestReq::_internal_set_full_udp_latency(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.full_udp_latency_ = value;
}

// bool full_nat = 11 [deprecated = true];
inline void TestReq::clear_full_nat() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.full_nat_ = false;
}
inline bool TestReq::full_nat() const {
  // @@protoc_insertion_point(field_get:libcore.TestReq.full_nat)
  return _internal_full_nat();
}
inline void TestReq::set_full_nat(bool value) {
  _internal_set_full_nat(value);
  // @@protoc_insertion_point(field_set:libcore.TestReq.full_nat)
}
inline bool TestReq::_internal_full_nat() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.full_nat_;
}
inline void TestReq::_internal_set_full_nat(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.full_nat_ = value;
}

// -------------------------------------------------------------------

// TestResp

// string error = 1;
inline void TestResp::clear_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_.ClearToEmpty();
}
inline const std::string& TestResp::error() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:libcore.TestResp.error)
  return _internal_error();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TestResp::set_error(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:libcore.TestResp.error)
}
inline std::string* TestResp::mutable_error() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:libcore.TestResp.error)
  return _s;
}
inline const std::string& TestResp::_internal_error() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.error_.Get();
}
inline void TestResp::_internal_set_error(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_.Set(value, GetArena());
}
inline std::string* TestResp::_internal_mutable_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.error_.Mutable( GetArena());
}
inline std::string* TestResp::release_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:libcore.TestResp.error)
  return _impl_.error_.Release();
}
inline void TestResp::set_allocated_error(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:libcore.TestResp.error)
}

// int32 ms = 2;
inline void TestResp::clear_ms() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ms_ = 0;
}
inline ::int32_t TestResp::ms() const {
  // @@protoc_insertion_point(field_get:libcore.TestResp.ms)
  return _internal_ms();
}
inline void TestResp::set_ms(::int32_t value) {
  _internal_set_ms(value);
  // @@protoc_insertion_point(field_set:libcore.TestResp.ms)
}
inline ::int32_t TestResp::_internal_ms() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ms_;
}
inline void TestResp::_internal_set_ms(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ms_ = value;
}

// string full_report = 3;
inline void TestResp::clear_full_report() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.full_report_.ClearToEmpty();
}
inline const std::string& TestResp::full_report() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:libcore.TestResp.full_report)
  return _internal_full_report();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TestResp::set_full_report(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.full_report_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:libcore.TestResp.full_report)
}
inline std::string* TestResp::mutable_full_report() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_full_report();
  // @@protoc_insertion_point(field_mutable:libcore.TestResp.full_report)
  return _s;
}
inline const std::string& TestResp::_internal_full_report() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.full_report_.Get();
}
inline void TestResp::_internal_set_full_report(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.full_report_.Set(value, GetArena());
}
inline std::string* TestResp::_internal_mutable_full_report() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.full_report_.Mutable( GetArena());
}
inline std::string* TestResp::release_full_report() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:libcore.TestResp.full_report)
  return _impl_.full_report_.Release();
}
inline void TestResp::set_allocated_full_report(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.full_report_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.full_report_.IsDefault()) {
    _impl_.full_report_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:libcore.TestResp.full_report)
}

// -------------------------------------------------------------------

// QueryStatsReq

// string tag = 1;
inline void QueryStatsReq::clear_tag() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tag_.ClearToEmpty();
}
inline const std::string& QueryStatsReq::tag() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:libcore.QueryStatsReq.tag)
  return _internal_tag();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryStatsReq::set_tag(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tag_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:libcore.QueryStatsReq.tag)
}
inline std::string* QueryStatsReq::mutable_tag() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_tag();
  // @@protoc_insertion_point(field_mutable:libcore.QueryStatsReq.tag)
  return _s;
}
inline const std::string& QueryStatsReq::_internal_tag() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.tag_.Get();
}
inline void QueryStatsReq::_internal_set_tag(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tag_.Set(value, GetArena());
}
inline std::string* QueryStatsReq::_internal_mutable_tag() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.tag_.Mutable( GetArena());
}
inline std::string* QueryStatsReq::release_tag() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:libcore.QueryStatsReq.tag)
  return _impl_.tag_.Release();
}
inline void QueryStatsReq::set_allocated_tag(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tag_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.tag_.IsDefault()) {
    _impl_.tag_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:libcore.QueryStatsReq.tag)
}

// string direct = 2;
inline void QueryStatsReq::clear_direct() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.direct_.ClearToEmpty();
}
inline const std::string& QueryStatsReq::direct() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:libcore.QueryStatsReq.direct)
  return _internal_direct();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryStatsReq::set_direct(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.direct_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:libcore.QueryStatsReq.direct)
}
inline std::string* QueryStatsReq::mutable_direct() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_direct();
  // @@protoc_insertion_point(field_mutable:libcore.QueryStatsReq.direct)
  return _s;
}
inline const std::string& QueryStatsReq::_internal_direct() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.direct_.Get();
}
inline void QueryStatsReq::_internal_set_direct(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.direct_.Set(value, GetArena());
}
inline std::string* QueryStatsReq::_internal_mutable_direct() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.direct_.Mutable( GetArena());
}
inline std::string* QueryStatsReq::release_direct() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:libcore.QueryStatsReq.direct)
  return _impl_.direct_.Release();
}
inline void QueryStatsReq::set_allocated_direct(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.direct_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.direct_.IsDefault()) {
    _impl_.direct_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:libcore.QueryStatsReq.direct)
}

// -------------------------------------------------------------------

// QueryStatsResp

// int64 traffic = 1;
inline void QueryStatsResp::clear_traffic() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.traffic_ = ::int64_t{0};
}
inline ::int64_t QueryStatsResp::traffic() const {
  // @@protoc_insertion_point(field_get:libcore.QueryStatsResp.traffic)
  return _internal_traffic();
}
inline void QueryStatsResp::set_traffic(::int64_t value) {
  _internal_set_traffic(value);
  // @@protoc_insertion_point(field_set:libcore.QueryStatsResp.traffic)
}
inline ::int64_t QueryStatsResp::_internal_traffic() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.traffic_;
}
inline void QueryStatsResp::_internal_set_traffic(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.traffic_ = value;
}

// -------------------------------------------------------------------

// UpdateReq

// .libcore.UpdateAction action = 1;
inline void UpdateReq::clear_action() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.action_ = 0;
}
inline ::libcore::UpdateAction UpdateReq::action() const {
  // @@protoc_insertion_point(field_get:libcore.UpdateReq.action)
  return _internal_action();
}
inline void UpdateReq::set_action(::libcore::UpdateAction value) {
  _internal_set_action(value);
  // @@protoc_insertion_point(field_set:libcore.UpdateReq.action)
}
inline ::libcore::UpdateAction UpdateReq::_internal_action() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::libcore::UpdateAction>(_impl_.action_);
}
inline void UpdateReq::_internal_set_action(::libcore::UpdateAction value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.action_ = value;
}

// bool check_pre_release = 2;
inline void UpdateReq::clear_check_pre_release() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.check_pre_release_ = false;
}
inline bool UpdateReq::check_pre_release() const {
  // @@protoc_insertion_point(field_get:libcore.UpdateReq.check_pre_release)
  return _internal_check_pre_release();
}
inline void UpdateReq::set_check_pre_release(bool value) {
  _internal_set_check_pre_release(value);
  // @@protoc_insertion_point(field_set:libcore.UpdateReq.check_pre_release)
}
inline bool UpdateReq::_internal_check_pre_release() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.check_pre_release_;
}
inline void UpdateReq::_internal_set_check_pre_release(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.check_pre_release_ = value;
}

// -------------------------------------------------------------------

// UpdateResp

// string error = 1;
inline void UpdateResp::clear_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_.ClearToEmpty();
}
inline const std::string& UpdateResp::error() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:libcore.UpdateResp.error)
  return _internal_error();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UpdateResp::set_error(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:libcore.UpdateResp.error)
}
inline std::string* UpdateResp::mutable_error() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:libcore.UpdateResp.error)
  return _s;
}
inline const std::string& UpdateResp::_internal_error() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.error_.Get();
}
inline void UpdateResp::_internal_set_error(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_.Set(value, GetArena());
}
inline std::string* UpdateResp::_internal_mutable_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.error_.Mutable( GetArena());
}
inline std::string* UpdateResp::release_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:libcore.UpdateResp.error)
  return _impl_.error_.Release();
}
inline void UpdateResp::set_allocated_error(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:libcore.UpdateResp.error)
}

// string assets_name = 2;
inline void UpdateResp::clear_assets_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.assets_name_.ClearToEmpty();
}
inline const std::string& UpdateResp::assets_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:libcore.UpdateResp.assets_name)
  return _internal_assets_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UpdateResp::set_assets_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.assets_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:libcore.UpdateResp.assets_name)
}
inline std::string* UpdateResp::mutable_assets_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_assets_name();
  // @@protoc_insertion_point(field_mutable:libcore.UpdateResp.assets_name)
  return _s;
}
inline const std::string& UpdateResp::_internal_assets_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.assets_name_.Get();
}
inline void UpdateResp::_internal_set_assets_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.assets_name_.Set(value, GetArena());
}
inline std::string* UpdateResp::_internal_mutable_assets_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.assets_name_.Mutable( GetArena());
}
inline std::string* UpdateResp::release_assets_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:libcore.UpdateResp.assets_name)
  return _impl_.assets_name_.Release();
}
inline void UpdateResp::set_allocated_assets_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.assets_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.assets_name_.IsDefault()) {
    _impl_.assets_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:libcore.UpdateResp.assets_name)
}

// string download_url = 3;
inline void UpdateResp::clear_download_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.download_url_.ClearToEmpty();
}
inline const std::string& UpdateResp::download_url() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:libcore.UpdateResp.download_url)
  return _internal_download_url();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UpdateResp::set_download_url(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.download_url_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:libcore.UpdateResp.download_url)
}
inline std::string* UpdateResp::mutable_download_url() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_download_url();
  // @@protoc_insertion_point(field_mutable:libcore.UpdateResp.download_url)
  return _s;
}
inline const std::string& UpdateResp::_internal_download_url() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.download_url_.Get();
}
inline void UpdateResp::_internal_set_download_url(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.download_url_.Set(value, GetArena());
}
inline std::string* UpdateResp::_internal_mutable_download_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.download_url_.Mutable( GetArena());
}
inline std::string* UpdateResp::release_download_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:libcore.UpdateResp.download_url)
  return _impl_.download_url_.Release();
}
inline void UpdateResp::set_allocated_download_url(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.download_url_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.download_url_.IsDefault()) {
    _impl_.download_url_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:libcore.UpdateResp.download_url)
}

// string release_url = 4;
inline void UpdateResp::clear_release_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.release_url_.ClearToEmpty();
}
inline const std::string& UpdateResp::release_url() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:libcore.UpdateResp.release_url)
  return _internal_release_url();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UpdateResp::set_release_url(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.release_url_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:libcore.UpdateResp.release_url)
}
inline std::string* UpdateResp::mutable_release_url() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_release_url();
  // @@protoc_insertion_point(field_mutable:libcore.UpdateResp.release_url)
  return _s;
}
inline const std::string& UpdateResp::_internal_release_url() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.release_url_.Get();
}
inline void UpdateResp::_internal_set_release_url(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.release_url_.Set(value, GetArena());
}
inline std::string* UpdateResp::_internal_mutable_release_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.release_url_.Mutable( GetArena());
}
inline std::string* UpdateResp::release_release_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:libcore.UpdateResp.release_url)
  return _impl_.release_url_.Release();
}
inline void UpdateResp::set_allocated_release_url(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.release_url_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.release_url_.IsDefault()) {
    _impl_.release_url_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:libcore.UpdateResp.release_url)
}

// string release_note = 5;
inline void UpdateResp::clear_release_note() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.release_note_.ClearToEmpty();
}
inline const std::string& UpdateResp::release_note() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:libcore.UpdateResp.release_note)
  return _internal_release_note();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UpdateResp::set_release_note(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.release_note_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:libcore.UpdateResp.release_note)
}
inline std::string* UpdateResp::mutable_release_note() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_release_note();
  // @@protoc_insertion_point(field_mutable:libcore.UpdateResp.release_note)
  return _s;
}
inline const std::string& UpdateResp::_internal_release_note() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.release_note_.Get();
}
inline void UpdateResp::_internal_set_release_note(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.release_note_.Set(value, GetArena());
}
inline std::string* UpdateResp::_internal_mutable_release_note() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.release_note_.Mutable( GetArena());
}
inline std::string* UpdateResp::release_release_note() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:libcore.UpdateResp.release_note)
  return _impl_.release_note_.Release();
}
inline void UpdateResp::set_allocated_release_note(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.release_note_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.release_note_.IsDefault()) {
    _impl_.release_note_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:libcore.UpdateResp.release_note)
}

// bool is_pre_release = 6;
inline void UpdateResp::clear_is_pre_release() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_pre_release_ = false;
}
inline bool UpdateResp::is_pre_release() const {
  // @@protoc_insertion_point(field_get:libcore.UpdateResp.is_pre_release)
  return _internal_is_pre_release();
}
inline void UpdateResp::set_is_pre_release(bool value) {
  _internal_set_is_pre_release(value);
  // @@protoc_insertion_point(field_set:libcore.UpdateResp.is_pre_release)
}
inline bool UpdateResp::_internal_is_pre_release() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_pre_release_;
}
inline void UpdateResp::_internal_set_is_pre_release(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_pre_release_ = value;
}

// -------------------------------------------------------------------

// ListConnectionsResp

// string nekoray_connections_json = 1;
inline void ListConnectionsResp::clear_nekoray_connections_json() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nekoray_connections_json_.ClearToEmpty();
}
inline const std::string& ListConnectionsResp::nekoray_connections_json() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:libcore.ListConnectionsResp.nekoray_connections_json)
  return _internal_nekoray_connections_json();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ListConnectionsResp::set_nekoray_connections_json(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nekoray_connections_json_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:libcore.ListConnectionsResp.nekoray_connections_json)
}
inline std::string* ListConnectionsResp::mutable_nekoray_connections_json() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_nekoray_connections_json();
  // @@protoc_insertion_point(field_mutable:libcore.ListConnectionsResp.nekoray_connections_json)
  return _s;
}
inline const std::string& ListConnectionsResp::_internal_nekoray_connections_json() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.nekoray_connections_json_.Get();
}
inline void ListConnectionsResp::_internal_set_nekoray_connections_json(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nekoray_connections_json_.Set(value, GetArena());
}
inline std::string* ListConnectionsResp::_internal_mutable_nekoray_connections_json() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.nekoray_connections_json_.Mutable( GetArena());
}
inline std::string* ListConnectionsResp::release_nekoray_connections_json() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:libcore.ListConnectionsResp.nekoray_connections_json)
  return _impl_.nekoray_connections_json_.Release();
}
inline void ListConnectionsResp::set_allocated_nekoray_connections_json(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nekoray_connections_json_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.nekoray_connections_json_.IsDefault()) {
    _impl_.nekoray_connections_json_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:libcore.ListConnectionsResp.nekoray_connections_json)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace libcore


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::libcore::TestMode> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::libcore::TestMode>() {
  return ::libcore::TestMode_descriptor();
}
template <>
struct is_proto_enum<::libcore::UpdateAction> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::libcore::UpdateAction>() {
  return ::libcore::UpdateAction_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // libcore_2eproto_2epb_2eh
